

/**
 public class TreeNode {
 int val = 0;
 TreeNode left = null;
 TreeNode right = null;

 public TreeNode(int val) {
 this.val = val;

 }

 }
 */

import java.util.Stack;

/**     操作给定的二叉树，将其变换为源二叉树的镜像。
 *           8
 *     	   /  \
 *     	  6   10
 *     	 / \  / \
 *     	5  7 9 11
 *     	镜像二叉树
 *     	    8
 *     	   /  \
 *     	  10   6
 *     	 / \  / \
 *     	11 9 7  5
 */
public class MirrorofTreeNode {
    //递归
    public void MirrorWithRec(TreeNode root) {
        if(root == null )
            return;
        if(root.left != null || root.right != null){
            TreeNode temp = root.left;
            root.left = root.right;
            root.right = temp;
            Mirror(root.left);
            Mirror(root.right);
        }

    }

    /**
     * 思路2：先序遍历，如果根节点不为 null 将根节点入栈，当栈不为 null 出栈，交换左右节点，如果左右节点不为 null 入栈。
     * @param root
     */
    //非递归
    public void Mirror(TreeNode root){
        if(root == null || (root.left == null && root.right == null) )
            return;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode current = stack.pop();
            //交换左右根节点
            TreeNode temp=current.right;
            current.right=current.left;
            current.left=temp;

            if(current.right != null){
                stack.push(current.right);
            }
            if(current.left != null){
                stack.push(current.left);
            }
        }
    }

}
